==============================================================================
SOUNDNESS COMPARISON — dataset1/arithmetic
==============================================================================

Per-rule classification:
  TP = Tool correctly reported violation  | TN = Tool correctly verified property
  FP = Tool wrongly reported violation    | FN = Tool missed actual violation
  Error = ANNOTATION ERROR (SVS) / COMPILATION ERROR (CVL)

Note: SVS uses --arithmetic mod-overflow flag, which detects any overflow/underflow
during function execution. CVL uses mathematical integers in rule assertions, so
wrapping overflow in the contract ≠ mathematical result → assertion fails.

--- 1. insecure_transfer (IntegerOverflowAdd) ---
Bug: balanceOf[_to] += _value can overflow in transfer().

  [SVS] 1 rule:
    transfer_conserves                  Expected: FAIL  Result: ERROR  → TP
      (Overflow in balanceOf[_to] += _value detected by mod-overflow.)

  [CVL] 1 rule:
    transfer_conserves                  Expected: FAIL  Result: ERROR  → TP
      (CVL math: to_after ≠ to_before + _value when overflow wraps.)

--- 2. integer_overflow_1 (Overflow) ---
Bug: sellerBalance += value can overflow in add().

  [SVS] 1 rule:
    add_no_overflow                     Expected: FAIL  Result: ERROR  → TP
      (Overflow in sellerBalance += value detected by mod-overflow.)

  [CVL] 0 rules — COMPILATION ERROR:
    Compilation failed due to "Warning: Unnamed return variable".
    Classification: Error

--- 3. integer_overflow_add (IntegerOverflowAdd) ---
Bug: count += input can overflow in run().

  [SVS] 1 rule:
    add_no_overflow                     Expected: FAIL  Result: ERROR  → TP

  [CVL] 1 rule:
    add_no_overflow                     Expected: FAIL  Result: ERROR  → TP

--- 4. integer_overflow_benign_1 (IntegerOverflowBenign1) ---
Bug: uint res = count - input can underflow in run(). Result only in local var.

  [SVS] 1 rule:
    run_underflow_should_revert         Expected: FAIL  Result: ERROR  → TP
      (Underflow in count - input detected by mod-overflow. State unchanged
       but overflow exists in computation. mod-overflow correctly flags it.)

  [CVL] 1 rule:
    run_underflow_should_revert         Expected: PASS  Result: OK     → TN
      (count state variable unchanged after run(). CVL doesn't flag local
       underflow since count == beforeCount holds mathematically.)

--- 5. integer_overflow_mapping_sym_1 (IntegerOverflowMappingSym1) ---
Bug: map[k] -= v can underflow in init().

  [SVS] 1 rule:
    init_underflow_should_revert        Expected: FAIL  Result: ERROR  → TP
      (Underflow in map[k] -= v detected by mod-overflow.)

  [CVL] 1 rule:
    init_underflow_should_revert        Expected: FAIL  Result: ERROR  → TP
      (CVL math: afterVal ≠ beforeVal - v when underflow wraps.)

--- 6. integer_overflow_minimal (IntegerOverflowMinimal) ---
Bug: count -= input can underflow in run(). Rule constrains input <= count.

  [SVS] 1 rule:
    sub_no_underflow                    Expected: PASS  Result: OK     → TN
      (With require input <= count, no underflow. Safe subtraction.)

  [CVL] 1 rule:
    sub_no_underflow                    Expected: PASS  Result: OK     → TN

--- 7. integer_overflow_mul (IntegerOverflowMul) ---
Bug: count *= input can overflow in run().

  [SVS] 1 rule:
    mul_no_overflow                     Expected: FAIL  Result: ERROR  → TP

  [CVL] 1 rule:
    mul_no_overflow                     Expected: FAIL  Result: ERROR  → TP

--- 8. integer_overflow_multitx_multifunc_feasible (IntegerOverflowMultiTxMultiFuncFeasible) ---
Bug: count -= input can underflow in run() after init().

  [SVS] 1 rule:
    run_after_init                      Expected: FAIL  Result: ERROR  → TP
      (With initialized==1, count -= input executes. No guard on input <= count.)

  [CVL] 1 rule:
    run_after_init                      Expected: FAIL  Result: ERROR  → TP

--- 9. integer_overflow_multitx_onefunc_feasible (IntegerOverflowMultiTxOneFuncFeasible) ---
Bug: count -= input can underflow in run() on second call.

  [SVS] 1 rule:
    run_after_second_call               Expected: FAIL  Result: ERROR  → TP

  [CVL] 1 rule:
    run_after_second_call               Expected: FAIL  Result: ERROR  → TP

--- 10. overflow_simple_add (Overflow_Add) ---
Bug: balance += deposit can overflow in add().

  [SVS] 1 rule:
    add_no_overflow                     Expected: FAIL  Result: ERROR  → TP

  [CVL] 1 rule:
    add_no_overflow                     Expected: FAIL  Result: ERROR  → TP

--- 11. overflow_single_tx (IntegerOverflowSingleTransaction) ---
Bug: Multiple functions with add/mul overflow and sub underflow.

  [SVS] 3 rules:
    add_state_no_overflow               Expected: FAIL  Result: ERROR  → TP
      (count += input overflows.)
    mul_state_no_overflow               Expected: FAIL  Result: ERROR  → TP
      (count *= input overflows.)
    sub_state_no_underflow              Expected: PASS  Result: ERROR  → FP
      (Rule requires input <= count, calls underflowtostate only.
       Subtraction is safe with guard. BUT SVS mod-overflow flags overflows
       in OTHER functions (5/6 functions overflow). This is a false positive:
       the specific property holds but unrelated function overflows trigger error.)

  [CVL] 3 rules:
    add_state_no_overflow               Expected: FAIL  Result: ERROR  → TP
    mul_state_no_overflow               Expected: FAIL  Result: ERROR  → TP
    sub_state_no_underflow              Expected: PASS  Result: OK     → TN
      (CVL correctly verifies: with input <= count, subtraction is safe.)

--- 12. timelock (TimeLock) ---
Bug: lockTime[msg.sender] += _secondsToIncrease can overflow.

  [SVS] 1 rule:
    locktime_monotone                   Expected: FAIL  Result: ERROR  → TP
      (Overflow in lockTime addition detected by mod-overflow.)

  [CVL] 1 rule:
    locktime_monotone                   Expected: FAIL  Result: ERROR  → TP

--- 13. token (Token) ---
Bug: require(balances[msg.sender] - _value >= 0) always true for uint (underflow
     wraps to huge number). transfer allows spending more than balance.

  [SVS] 1 rule:
    transfer_balance_conservation       Expected: FAIL  Result: ERROR  → TP
      (Underflow in balances[msg.sender] -= _value detected.)

  [CVL] 1 rule:
    transfer_balance_conservation       Expected: FAIL  Result: ERROR  → TP
      (CVL assertion sender_before >= _value fails when sender_before < _value
       since the bogus require doesn't prevent it.)

--- 14. tokensalechallenge (TokenSaleChallenge) ---
Bug: numTokens * PRICE_PER_TOKEN can overflow in buy() and sell().

  [SVS] 2 rules:
    buy_adds_balance                    Expected: FAIL  Result: ERROR  → TP
      (Overflow in numTokens * PRICE_PER_TOKEN and balanceOf += numTokens.)
    sell_decreases_balance              Expected: FAIL  Result: ERROR  → TP
      (Overflow in numTokens * PRICE_PER_TOKEN in sell's transfer call.
       Balance assertion would hold, but mod-overflow catches the
       multiplication overflow in the function execution.)

  [CVL] 2 rules:
    buy_adds_balance                    Expected: FAIL  Result: ERROR  → TP
      (CVL math: afterBal ≠ beforeBal + numTokens when balanceOf += overflows.)
    sell_decreases_balance              Expected: PASS  Result: OK     → TN
      (Balance subtraction is safe (require balance >= numTokens).
       CVL assertion about balance holds. Overflow in transfer amount
       is not checked by this rule.)

==============================================================================
SUMMARY — dataset1/arithmetic
==============================================================================

                     solc-verify-spec          Certora
  TP:                      15                      12
  TN:                       1                       4
  FP:                       1                       0
  FN:                       0                       0
  Error:                    0                       1
  ──────────────────────────────────────────────────────
  Total rules:             17                      16
  Compilation Error:        0                       1

  Detection metrics (SVS, excluding Error):
    Precision: 15/(15+1) = 93.8%
    Recall:    15/(15+0) = 100.0%

  Detection metrics (CVL, excluding Error):
    Precision: 12/(12+0) = 100.0%
    Recall:    12/(12+0) = 100.0%

==============================================================================
